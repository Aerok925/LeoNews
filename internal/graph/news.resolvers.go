package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"log"

	"github.com/Aerok925/LeoNews/internal/graph/model"
	"github.com/Aerok925/LeoNews/internal/models"
	"github.com/Aerok925/LeoNews/internal/service"
)

// CreateNews is the resolver for the createNews field.
func (r *mutationResolver) CreateNews(ctx context.Context, input model.NewNews) (*model.News, error) {
	model1 := models.News{
		Title:       input.Title,
		Description: input.Description,
		Img:         input.Img,
	}

	repsNew, err := service.NewsService.Create(ctx, model1)
	if err != nil {
		return nil, err
	}
	respModel := &model.News{
		ID:          repsNew.ID,
		Title:       repsNew.Title,
		Description: repsNew.Description,
		Img:         repsNew.Img,
		CreateAt:    repsNew.CreatedAt,
	}
	return respModel, err
}

// GetNews is the resolver for the getNews field.
func (r *queryResolver) GetNews(ctx context.Context, id *int) ([]*model.News, error) {
	news, err := service.NewsService.GetAll(ctx)
	if err != nil {
		return nil, err
	}

	resp := make([]*model.News, 0)
	for _, m := range news {
		model := &model.News{
			ID:          m.ID,
			Title:       m.Title,
			Description: m.Description,
			Img:         m.Img,
			CreateAt:    m.CreatedAt,
		}
		resp = append(resp, model)
	}
	return resp, nil
}

// NewsPublished is the resolver for the newsPublished field.
func (r *subscriptionResolver) NewsPublished(ctx context.Context) (<-chan *model.News, error) {
	newsCh, err := service.NewsService.SubscribeNews(ctx)
	if err != nil {
		return nil, err
	}
	respCh := make(chan *model.News)
	go func() {
		for data := range newsCh {
			log.Println(data)
			model := &model.News{
				ID:          data.ID,
				Title:       data.Title,
				Description: data.Description,
				Img:         data.Img,
				CreateAt:    data.CreatedAt,
			}
			respCh <- model
		}
		close(respCh)
	}()
	return respCh, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
